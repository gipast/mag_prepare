class monstr
{
  int health, ammo;

public:
  monstr(int he = 100, int am = 10)
  {
    health = he;
    ammo = am;  
  }
  void draw(int x, int y, int sale, int position);
  int get_health() {return health;}
  int get_ammo() {return ammo;}
};

запрещено определять следующие типы функций:
- рекурсивные функции;
- виртуальные функции.
Тела таких функций размещаются вне пределов класса.




В случае, когда обращаются к const объекту, к нему применяется только const методы.
Объект типа const (константный объект)- объект, значение полей которого изменять запрещено.

class monstr
{…

int get_health() const {return health;}
};


параметры конструктора могут иметь любой тип, кроме типа этого же класса; можно задавать значения по умолчанию, но их может содержать только один конструктор


Существует еще один способ инициализации полей в конструкторе - инициализация с помощью списка инициализации, расположенного после «:» между заголовком тела и конструктором.

monstr::monst(int he, int am): health(he), ammo(am), skin(red), name(0);

Поля перечисляются через запятую. Для каждого поля в скобках указывается инициализирующее значение, которое может быть выражением. 

// деструктор
   ~String();

    не имеет аргументов и возвращающего значения
    не может быть объявлен как const или static (но может быть virtual)
    не наследуется


К элементам класса можно обращаться с помощью указателей. Для этого определены следующие операции: .* и –> . Указатели на поля и методы класса определены по-разному.
Формат указателя на метод класса: <возвращаемый_тип> (<имя_класса>::*<имя_указателя>)(<параметр>)

Как и указатели на обычные функции, указатели на методы класса используются в том случае, когда возникает необходимость вызывать метод, имя которого неизвестно. Однако существуют различия между указателем на метод и на функцию (имя переменной). Указатель на метод не ссылается на определенный адрес памяти. Указатель на метод имеет сходство с индексом в массиве, так как задает смещение. Конкретный адрес в памяти получается путем сочетания указателя на метод класса с указателем на определенный объект.




Формат указателя на поле класса: <тип_данных>(<имя_класса>::*<имя_указателя>);

В определение указателя можно включить его инициализацию в такой форме: &имя_класса::имя_поля; При это поле должно быть в области public.



monstr &the_best(monstr &M)
{
  if(health > M.get_health())
    return *this;
  return M;
}



Предназначены для обращения к статическим полям класса. Обращение к статическим методам производится так же, как и к статическим полям, а именно:
а) через имя класса,
б) через имя объекта, если он уже создан.
Пример 1

class A 
{
	static int count; /* поле count - скрытое */
	public:
		static void int_count() {count++}
};
A::int count; /* определение в глобальной области*/

void f()
{
	A.a;
	/* a.count++ - нельзя, так как поле count   скрытое. 
	Изменение поля count выглядит следующим образом: */
	a.inc_count(); 
	/*или :*/
	A::inc_count();
}

class String {
 public:
   // набор конструкторов
   // для автоматической инициализации
   // String strl;              // String()
   // String str2( "literal" ); // String( const char* );
   // String str3( str2 );      // String( const String& );
 
   String();
   String( const char* );
   String( const String& );
 
   // деструктор
   ~String();
 
   // операторы присваивания
   // strl = str2
   // str3 = "a string literal"
 
   String& operator=( const String& );
   String& operator=( const char* );
 
   // операторы проверки на равенство
   // strl == str2;
   // str3 == "a string literal";
 
   bool operator==( const String& );
   bool operator==( const char* );
 
   // перегрузка оператора доступа по индексу
   // strl[ 0 ] = str2[ 0 ];
 
   char& operator[]( int );
 
   // доступ к членам класса
   int   size() { return _size; }
   char* c_str() { return _string; }
 
 private:
   int  _size;
   char *_string;
 }


namespace staff
{
class monstr{...};
class hero{...};
void interact(hero, monstr);
}





Класс, объявленный внутри другого класса, называют вложенным. Вложенный класс находится в области действия того класса, внутри которого он объявлен. Соответственно, объекты вложенного класса могут использовать компоненты внешнего класса, а компонентные функции и статические компоненты вложенного класса могут быть описаны вне глобального класса.

Пример 1

class Figura {

	class Point               // вложенный класс Point
	{
		int x, y, color;
		public:
		int getx() { return x; }
		int gety() { return y; }
		int getcolor() { return color; }
		.......
	};

	class Line                // вложенный класс Line
	{
		Point Tn, Tk;             // начало и конец линии
		public:
		void draw(void)           // метод рисования линии
		{
		....
		line(Tn.getx(), Tn.gety(), Tk.getx(), Tk.gety());
		}

		void setline(int ncolor) {....}
	};


};


class name:[private|protected|public] parent_class;

class A{...};
class B{...};
class C{...};
class D:A, protected B, public C {...};


class base
{
...
public: void f();
};

class derived:private base
{
...
public: base::void f();
};



если в конструкторе производного класса осуществляется явный вызов конструкторов базового класса. Если он отсутствует, автоматически вызывается конструктор базового класса по умолчанию (тот, который можно вызывать без параметров)

Если конструктор базового класса требует указания параметров, он должен быть вызван явным образом в конструкторе производного класса в списке инициализации.

Не наследуются операция присваивания, следовательно её требуется явно определить в производном классе




Когда механизм наследования осуществляется от нескольких классов, то это множественное наследование. При множественном наследовании производный класс может включать произвольное количество базовых классов. Форма множественного наследования выглядит так:

class <имя производного класса>:
<вид наследования> <имя базового класса>
<вид наследования> <имя базового класса>
...
{...};




При наличии у конструктора базового класса одного или нескольких аргументов, каждый производный класс должен иметь конструктор. Чтобы передать аргумент в базовый класс, нужно определить их после объявления конструктора производного класса.
<имя конструктора производного класса> (<список аргументов>),
<имя конструктора базового класса 1> (<список аргументов>),
...
{<тело конструктора производного класса>}

class Z: public X, public Y{
	public:
		z(int i, int j); /* конструктор с параметром*/

}
z::z(int i, int j):	Y(j), X(i) 
{ 
	cout << ” конструктор Z \n”;
}


Чтобы избежать многократного включения в производный класс компонент базового класса, используется виртуальное наследование. 





непонятно
fixed(int fix)::fix(fix) /* конструктор с параметром */





При виртуальном наследовании производный класс описывается так:

сlass <имя производного класса>:
virtual <вид наследования> <имя базового класса>
{...};

class derived_1: virtual public fixed /* виртуальное наследование */
{
public:
	int one;
	derived_1(void) { cout<<”Вызов конструктора 1 \n”;};
};


class derived: public derived_1, public derived_2 /* объявление производного класса непрямого потомка */
{
public:
	derived(void) {cout<< “вызов конструктора derived” <<endl;}
	derived(int fix);

	//fixed(fix) { cout<<”вызов конструктора derived int“<<endl;}
	//void out() { cout<<”Fix = ”<< fix; 
}


Включение в производный класс полей базового класса осуществляется один раз, а их инициализация происходит в производном классе, который не является прямым потомком базового класса. Вызов конструкторов при этом происходит в следующем порядке:

    конструктор виртуально наследованного базового класса
    конструкторы базовых классов, в порядке их перечисления при объявлении
    конструкторы объектных полей
    конструктор производного класса

Деструкторы вызываются в обратном порядке.
Виртуально наследованный класс должен содержать конструктор без параметров. Он активизируется при выполнении конструкторов классов, являющихся прямыми потомками виртуально наследованного класса.




Динамический полиморфизм – выбор функции производится по используемому при выводе имени, типу вызываемого объекта и типу используемый параметров. Если объявленный тип не совпадает с типом использованного объекта, тип этого объекта идентифицируется и проверяется во время исполнения программы, что позволяет осуществить правильный выбор соответствующей функции. Это и называется динамическим полиморфизмом (поздним связыванием). Динамическое связывание приводит к небольшим издержкам памяти и времени выполнения программы, поэтому в C++ его используют только в случае явного указания, посредством ключевого слова virtual. Динамическое связывание используется путем объявления виртуальной функции.

virtual void change_size(const Point fnew_size);


... = 0

Виртуальная функция обязательно должна быть компонентой некоторого класса. 


Работа с объектами чаще всего производится через указатели. Указателю на базовый класс можно присвоить значение адреса объекта любого производного класса.
Пример 1

// Описывается указатель на базовый класс:
monstr *p:
// указатель ссылается наобъект производного класса:
p = new daemon;

Вызов методов объекта происходит в соответствии с типом указателя, а не фактическим типом объекта, на который он ссылается, поэтому при выполнении оператора, например, p->draw(1. 1, 1, 1); будет вызван метод класса monstr, а не класса daemon, поскольку ссылки на методы разрешаются во время компоновки программы. Этот процесс называется ранним связыванием или статическим полиморфизмом.






В C++ реализован механизм позднего связывания, когда разрешение ссылок на метод происходит на этапе выполнения программы в зависимости от конкретного типа объекта, вызвавшего метод. Этот механизм реализован с помощью виртуальных методов и рассмотрен в следующем разделе.
Для определения виртуального метода используется спецификатор virtual.
Пример 2

virtual void draw(int x, int y, int scale, int position); 

Рассмотрим правила описания и использования виртуальных методов.

    Если в базовом классе метод определен как виртуальный, метод, определенный в производном классе с тем же именем и набором параметров, автоматически становится виртуальным, а с отличающимся набором параметров — обычным.
    Виртуальные методы наследуются, то есть переопределять их в производном классе требуется только при необходимости задать отличающиеся действия. Права доступа при переопределении изменить нельзя.
    Если виртуальный метод переопределен в производном классе, объекты этого класса могут получить доступ к методу базового класса с помощью операции доступа к области видимости.
    Виртуальный метод не может объявляться с модификатором static
    Если в классе вводится описание виртуального метода, он должен быть определен хотя бы как чисто виртуальный. Чисто виртуальный метод содержит признак = 0 вместо тела.

virtual void f(int) = 0;

Чисто виртуальный метод должен переопределяться в производном классе (возможно, опять как чисто виртуальный).


monstr  *r,*p;
r = 
new monstr;
//
Создается объект
класса monstr
р = new daemon;
//
Создается объект
класса daemon
r->draw(1, 1, 1, 1);        //
Вызывается метод
monstr::draw
p->draw(1, 1, 1, 1);        //
Вызывается метод
daemon::draw


Рекомендуется делать виртуальными деструкторы для того, чтобы гарантировать правильное освобождение памяти из-под динамического объекта, поскольку в этом случае в любой момент времени будет выбран деструктор, соответствующий фактическому типу объекта. Деструктор передает операции delete размер объекта, имеющий тип size_t. Если удаляемый объект является производным и в нем не определен виртуальный деструктор, передаваемый размер объекта может оказаться неправильным.
Четкого правила, по которому метод следует делать виртуальным, не существует. Можно только дать рекомендацию объявлять виртуальными методы, для которых есть вероятность, что они будут переопределены в производных классах.



Виртуальный механизм работает только при использовании указателей или ссылок на объекты. Объект, определенный через указатель или ссылку и содержащий виртуальные методы, называется полиморфным.




Класс, содержащий хотя бы один чисто виртуальный метод, называется абстрактным. Абстрактные классы предназначены для представления общих понятий, которые предполагается конкретизировать в производных классах. Эти классы применяются при определении данных и методов, которые будут общими для различных производных классов. Создание классов, имеющих общим только поведение, осуществляется с помощью базового класса, в котором все функции-члены объявлены в разделе public, а в разделе private данных либо очень мало, либо вовсе нет. Абстрактный класс может использоваться только в качестве базового для других классов — объекты абстрактного класса создавать нельзя, поскольку прямой или косвенный вызов чисто виртуального метода приводит к ошибке при выполнении.
Функции-члены в абстрактных классах определяются через чистые виртуальные функции. Чистые виртуальные функции – функции, которые объявлены с ключом virtual, но не определяются. Они должны быть переопределены в производных классах.


    допускается объявлять указатели и ссылки на абстрактный класс, если при инициализации не требуется создавать временный объект;
    если класс, производный от абстрактного, не определяет все чисто виртуальные функции, он также является абстрактным.

Таким образом, можно создать функцию, параметром которой является указатель на абстрактный класс. На место этого параметра при выполнении программы может передаваться указатель на объект любого производного класса. Это позволяет создавать полиморфные функции, работающие с объектом любого типа в пределах одной иерархии.

class DIsplay_medium
{
public:
virtual Point size() const = 0;
virtual Point cursor() const = 0;
virtual int move_cursor(const Point &p) = 0;
virtual Display char character() const = 0;
virtual string Tine() caonst = 0;
virtual void add (DIsplar char ch) = 0;
virtual void add(const String &s) = 0;
virtual void clear();
};


Простейший шаблон функции имеет форму:

template <class Type> <заголовок>
{
<тело функции>
}


В общем случае шаблон функции может содержать несколько параметров, каждый из которых может быть не только типом, но и просто переменной.
Пример 1

template <class A, class B, int i> void f() {...}

Шаблон функции использует в качестве аргумента тип переменной.
Пример 2

template<class T>  Tsgr_it(T x)
{
...
return x*x;
}


